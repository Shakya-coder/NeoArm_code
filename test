import socket, threading, time

# Defaults
LISTEN_HOST = "0.0.0.0"
LISTEN_PORT = 9999

SOFT_THRESHOLD = 400
HARD_THRESHOLD = 800
DEFAULT_THRESHOLD = 600

# LED pins (BCM). Set when starting the module.
BLUE_LED_PIN = None
RED_LED_PIN = None
YELLOW_LED_PIN = None  # optional; if None fallback to blue+red for default

# runtime state
_lock = threading.Lock()
_CURRENT_CATEGORY = "default"   # "soft" / "hard" / "default"
_THRESHOLDS = [DEFAULT_THRESHOLD] * 5
_last_recv_ts = None

_server_thread = None
_server_stop = threading.Event()
_monitor_thread = None
_monitor_stop = threading.Event()

def _set_led(pi, category):
    """Set LED outputs (nonfatal)."""
    try:
        if pi is None:
            return
        if category == "soft":
            if BLUE_LED_PIN is not None:
                pi.write(BLUE_LED_PIN, 1)
            if RED_LED_PIN is not None:
                pi.write(RED_LED_PIN, 0)
            if YELLOW_LED_PIN is not None:
                pi.write(YELLOW_LED_PIN, 0)
        elif category == "hard":
            if BLUE_LED_PIN is not None:
                pi.write(BLUE_LED_PIN, 0)
            if RED_LED_PIN is not None:
                pi.write(RED_LED_PIN, 1)
            if YELLOW_LED_PIN is not None:
                pi.write(YELLOW_LED_PIN, 0)
        else:  # default
            if YELLOW_LED_PIN is not None:
                if BLUE_LED_PIN is not None:
                    pi.write(BLUE_LED_PIN, 0)
                if RED_LED_PIN is not None:
                    pi.write(RED_LED_PIN, 0)
                pi.write(YELLOW_LED_PIN, 1)
            else:
                # fallback: show both blue+red ON
                if BLUE_LED_PIN is not None:
                    pi.write(BLUE_LED_PIN, 1)
                if RED_LED_PIN is not None:
                    pi.write(RED_LED_PIN, 1)
    except Exception:
        pass

def _apply_category(cat, pi=None):
    """Thread-safe apply category and update LED."""
    global _CURRENT_CATEGORY, _THRESHOLDS, _last_recv_ts
    with _lock:
        if cat == "soft":
            _CURRENT_CATEGORY = "soft"
            _THRESHOLDS = [SOFT_THRESHOLD] * 5
        elif cat == "hard":
            _CURRENT_CATEGORY = "hard"
            _THRESHOLDS = [HARD_THRESHOLD] * 5
        else:
            _CURRENT_CATEGORY = "default"
            _THRESHOLDS = [DEFAULT_THRESHOLD] * 5
        _last_recv_ts = time.time()
    # update LED outside lock
    _set_led(pi, _CURRENT_CATEGORY)

def _handle_connection(conn, addr, pi):
    try:
        data = conn.recv(1024)
        if not data:
            return
        msg = data.decode("utf-8", errors="ignore").strip().lower()
        if msg in ("soft", "hard"):
            _apply_category(msg, pi=pi)
            try:
                conn.sendall(b"OK\n")
            except Exception:
                pass
        else:
            try:
                conn.sendall(b"ERR\n")
            except Exception:
                pass
    except Exception:
        pass
    finally:
        try:
            conn.close()
        except:
            pass

def _server_loop(pi, host, port):
    s = None
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.bind((host, port))
        s.listen(1)
        s.settimeout(1.0)
    except Exception as e:
        if s:
            try: s.close()
            except: pass
        return

    while not _server_stop.is_set():
        try:
            conn, addr = s.accept()
        except socket.timeout:
            continue
        except Exception:
            break
        _handle_connection(conn, addr, pi)

    try:
        s.close()
    except:
        pass

def _monitor_loop(pi, timeout_s):
    """Monitor last recv time and revert to default when expired."""
    global _last_recv_ts
    while not _monitor_stop.is_set():
        now = time.time()
        with _lock:
            last = _last_recv_ts
        if last is None:
            # no message yet; ensure default category active
            _apply_category("default", pi=pi)
        else:
            if timeout_s is not None and (now - last) > timeout_s:
                # revert to default once
                _apply_category("default", pi=pi)
                # reset last_recv to avoid repeated revert logs
                with _lock:
                    _last_recv_ts = None
        time.sleep(0.5)

def start(pi=None, host=LISTEN_HOST, port=LISTEN_PORT,
          blue_pin=None, red_pin=None, yellow_pin=None, timeout_s=40):
    """
    Start server and monitor threads.
      - pi: pigpio.pi() instance (optional, for LEDs)
      - blue_pin/red_pin/yellow_pin: BCM pins for LEDs (optional)
      - timeout_s: seconds to revert to default when no new message received (None disables revert)
    Returns True if started, False if already running.
    """
    global _server_thread, _server_stop, BLUE_LED_PIN, RED_LED_PIN, YELLOW_LED_PIN
    global _monitor_thread, _monitor_stop
    if _server_thread and _server_thread.is_alive():
        return False
    BLUE_LED_PIN = blue_pin
    RED_LED_PIN = red_pin
    YELLOW_LED_PIN = yellow_pin
    _server_stop.clear()
    _monitor_stop.clear()
    _server_thread = threading.Thread(target=_server_loop, args=(pi, host, port), daemon=True)
    _server_thread.start()
    _monitor_thread = threading.Thread(target=_monitor_loop, args=(pi, timeout_s), daemon=True)
    _monitor_thread.start()
    # ensure initial LED state is default
    _apply_category("default", pi=pi)
    return True

def stop():
    """Stop server & monitor threads."""
    global _server_stop, _monitor_stop, _server_thread, _monitor_thread
    _server_stop.set()
    _monitor_stop.set()
    if _server_thread:
        _server_thread.join(timeout=1.0)
        _server_thread = None
    if _monitor_thread:
        _monitor_thread.join(timeout=1.0)
        _monitor_thread = None

def get_category():
    with _lock:
        return _CURRENT_CATEGORY

def get_thresholds():
    with _lock:
        return list(_THRESHOLDS)

def force_set_category(cat, pi=None):
    _apply_category(cat, pi=pi)
