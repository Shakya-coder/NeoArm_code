#!/usr/bin/env python3
# vision_lowlatency_picam.py â€” low-latency YOLO detection using PiCamera2 (no TCP stream)
# NeoArm version

import os, time, threading
from pathlib import Path
import cv2
import numpy as np
from ultralytics import YOLO
from picamera2 import Picamera2

# Force X11 for GUI
os.environ.setdefault("QT_QPA_PLATFORM", "xcb")

# === Config ===
MODEL_PATH = str(Path.home() / "NeoArm" / "vision" / "models" / "yolov8n.pt")
IMG_W, IMG_H = 640, 480
INFER_IMGSZ = 320
CONF = 0.30

CATEGORY_MAP = {
    "bottle": "hard", "cup": "hard", "cell phone": "hard", "phone": "hard",
    "apple": "soft", "banana": "soft", "orange": "soft",
    "person": "unknown", "hand": "unknown"
}

def get_category(name):
    return CATEGORY_MAP.get(name.lower(), "unknown")

class FrameBuffer:
    """Holds exactly one latest frame (thread-safe)."""
    def __init__(self):
        self.lock = threading.Lock()
        self.frame = None
        self.ts = 0.0
    def put(self, f):
        with self.lock:
            self.frame = f
            self.ts = time.time()
    def get(self):
        with self.lock:
            return self.frame, self.ts

def capture_thread_func(buf: FrameBuffer, stop_event):
    """Continuously capture frames from PiCamera2."""
    picam2 = Picamera2()
    config = picam2.create_preview_configuration(main={"size": (IMG_W, IMG_H), "format": "RGB888"})
    picam2.configure(config)
    picam2.start()
    print("[vision] Camera started using PiCamera2...")

    while not stop_event.is_set():
        frame = picam2.capture_array()
        buf.put(frame)
        # Short sleep helps manage CPU usage slightly
        time.sleep(0.01)

    picam2.stop()
    print("[vision] Camera stopped.")

def inference_thread_func(model, buf: FrameBuffer, stop_event):
    """Continuously take latest frame from buffer, run YOLO inference."""
    names = getattr(model.model, "names", {})
    last_print = 0
    while not stop_event.is_set():
        frame, ts = buf.get()
        if frame is None:
            time.sleep(0.01)
            continue
        img = frame.copy()
        t0 = time.time()

        results = model.predict(source=[img], imgsz=INFER_IMGSZ, conf=CONF, max_det=5, verbose=False)
        t_elapsed = time.time() - t0
        detections = []

        if results and len(results) > 0:
            r = results[0]
            boxes = getattr(r, "boxes", [])
            for b in boxes:
                try:
                    conf = float(b.conf[0]) if hasattr(b.conf, "__len__") else float(b.conf)
                except:
                    conf = float(getattr(b, "conf", 0.0))
                try:
                    cls_i = int(b.cls[0]) if hasattr(b.cls, "__len__") else int(b.cls)
                except:
                    cls_i = int(getattr(b, "cls", 0))
                name = names.get(cls_i, str(cls_i))
                category = get_category(name)
                detections.append((name, conf, category))

        if detections:
            best = max(detections, key=lambda x: x[1])
            name, conf, category = best
            print(f"[{time.strftime('%H:%M:%S')}] DETECTED: {name} conf={conf:.2f} cat={category} (inf_time={t_elapsed:.2f}s)")
        else:
            if time.time() - last_print > 1.0:
                print(f"[{time.strftime('%H:%M:%S')}] DETECTED: none (inf_time={t_elapsed:.2f}s)")
                last_print = time.time()

        time.sleep(0.01)

def main():
    print("[vision] loading model", MODEL_PATH)
    model = YOLO(MODEL_PATH)

    buf = FrameBuffer()
    stop_event = threading.Event()
    cap_thread = threading.Thread(target=capture_thread_func, args=(buf, stop_event), daemon=True)
    inf_thread = threading.Thread(target=inference_thread_func, args=(model, buf, stop_event), daemon=True)

    cap_thread.start()
    inf_thread.start()

    print("[vision] running. Show an object in front of camera. Ctrl+C to stop.")
    try:
        while True:
            time.sleep(0.5)
    except KeyboardInterrupt:
        print("Stopping...")
        stop_event.set()
        cap_thread.join(timeout=1.0)
        inf_thread.join(timeout=1.0)
        print("Exited.")

if __name__ == "__main__":
    main()
