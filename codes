#!/usr/bin/env python3
"""
main.py - start hardware + webserver + loops.
Run inside venv: python3 main.py
"""

import time
import threading
import subprocess
import RPi.GPIO as GPIO
import pigpio

import data
import hardware
import webserver

# Pin assignment (confirmed)
PIN_WRIST = 23
PIN_ELBOW = 24
PIN_PUSH = 27  # GND -> Button -> GPIO27

# Setup GPIO for push button
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)
GPIO.setup(PIN_PUSH, GPIO.IN, pull_up_down=GPIO.PUD_UP)

# remove old detect if exists
try:
    GPIO.remove_event_detect(PIN_PUSH)
except Exception:
    pass

# Start pigpio daemon externally (ensure pigpiod running). Create pigpio instance.
pi = pigpio.pi()
if not pi.connected:
    print("[MAIN] ERROR: pigpio daemon not available. Start `sudo pigpiod` then run this script.")
else:
    print("[MAIN] pigpio connected.")

# Attach pigpio to hardware module
hardware.attach_pigpio(pi)

# mode and push state
current_mode = "button"
push_state = False

def set_mode(m):
    global current_mode
    current_mode = m
    hardware.set_mode(m)
    print(f"[MAIN] Mode changed to: {m}")

# push button callback
def _handle_push(channel):
    global push_state
    # only act in button mode
    if current_mode != "button":
        print("[MAIN] Button pressed but current mode is not 'button', ignored.")
        return
    print("[MAIN] Push button pressed (GPIO27)")
    if not push_state:
        print("[MAIN] Button-> closing all fingers")
        hardware.all_close()
        push_state = True
    else:
        print("[MAIN] Button-> opening all fingers")
        hardware.all_open()
        push_state = False

# register event detect (debounce)
try:
    GPIO.add_event_detect(PIN_PUSH, GPIO.FALLING, callback=_handle_push, bouncetime=200)
    print("[MAIN] Push button interrupt enabled on GPIO27")
except Exception as e:
    print("[MAIN] ERROR enabling push button interrupt:", e)

# joint thread (wrist + elbow)
def joint_loop():
    while True:
        try:
            wp = data.get_wrist_angle()
            ep = data.get_elbow_angle()
            # Map percent to pulsewidth and write with pigpio directly
            if hardware.pi is not None:
                pw_wrist = int(500 + (wp / 100.0) * 2000)
                pw_elbow = int(500 + (ep / 100.0) * 2000)
                hardware.pi.set_servo_pulsewidth(PIN_WRIST, pw_wrist)
                hardware.pi.set_servo_pulsewidth(PIN_ELBOW, pw_elbow)
            print(f"[JOINT] Wrist={wp:.1f}%, Elbow={ep:.1f}%")
        except Exception as e:
            print("[JOINT] error:", e)
        time.sleep(0.05)

threading.Thread(target=joint_loop, daemon=True).start()

# FSR loop - auto-grip
def fsr_loop():
    while True:
        try:
            if current_mode == "fsr":
                pressed = data.get_trigger_fsr()
                if pressed:
                    print("[FSR] pressed -> all_close")
                    hardware.all_close()
                else:
                    print("[FSR] released -> all_open")
                    hardware.all_open()
        except Exception as e:
            print("[FSR] error:", e)
        time.sleep(0.06)

threading.Thread(target=fsr_loop, daemon=True).start()

# Start webserver in-thread so it can call hardware functions directly
def start_webserver_thread():
    print("[MAIN] Starting webserver in-thread...")
    t = threading.Thread(target=webserver.run, daemon=True)
    t.start()
    time.sleep(0.5)
    print("[MAIN] Webserver started (http://<pi-ip>:8080)")

if __name__ == "__main__":
    print("[MAIN] NeoArm starting...")
    set_mode("button")
    start_webserver_thread()

    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("[MAIN] KeyboardInterrupt - shutting down.")
    finally:
        print("[MAIN] Cleaning up hardware and GPIO.")
        try:
            hardware.shutdown()
        except Exception:
            pass
        try:
            GPIO.cleanup()
        except Exception:
            pass
        try:
            if pi is not None:
                pi.stop()
        except Exception:
            pass
        print("[MAIN] Exit.")
