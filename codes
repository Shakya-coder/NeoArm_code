#!/usr/bin/env python3
# main.py  -- NeoArm controller (starts sensors, hardware, webserver)
# Run with: python3 main.py

import time
import threading
import pigpio
import os
import sys

import data
import hardware
import webserver

# Push button pin (GND <-- Button --> GPIO27)
PIN_PUSH = 27

# Joint pins (wrist/elbow) are handled in webserver/main joints; hardware.pi used by hardware
PIN_WRIST = 23
PIN_ELBOW = 24

# state
current_mode = "button"
push_state = False   # Option A: toggles between closed/open

# debounce
_last_button_tick = 0
DEBOUNCE_MS = 250

# pigpio instance
pi = pigpio.pi()
if not pi.connected:
    print("[MAIN] ERROR: pigpio daemon not available. Start `sudo pigpiod` first.")
    sys.exit(1)

print("[MAIN] pigpio connected")

# attach pigpio to hardware module
hardware.attach_pigpio(pi)

# configure button pin: input with pull-up (button to ground)
pi.set_mode(PIN_PUSH, pigpio.INPUT)
pi.set_pull_up_down(PIN_PUSH, pigpio.PUD_UP)

# callback handler using pigpio, with debounce
def _button_callback(gpio, level, tick):
    global _last_button_tick, push_state, current_mode
    # we want falling edge (pressed to ground) -> level == 0
    if level != 0:
        return
    now = tick  # pigpio tick (microsecond)
    # simple debounce: ignore events within DEBOUNCE_MS
    if _last_button_tick != 0:
        diff_ms = (now - _last_button_tick) / 1000.0
        if diff_ms < DEBOUNCE_MS:
            # ignore bounce
            return
    _last_button_tick = now

    # Only act if in button mode
    if current_mode != "button":
        print("[MAIN] Button pressed but current_mode != 'button' -> ignored")
        return

    print("[MAIN] Button pressed (GPIO27)")

    # Toggle behavior (Option A)
    if not push_state:
        print("[MAIN] Closing all fingers (button)")
        # run in separate thread so callback returns quickly and callback isn't blocked too long
        threading.Thread(target=hardware.all_close, daemon=True).start()
        push_state = True
    else:
        print("[MAIN] Opening all fingers (button)")
        threading.Thread(target=hardware.all_open, daemon=True).start()
        push_state = False

# register pigpio callback
cb = pi.callback(PIN_PUSH, pigpio.FALLING_EDGE, _button_callback)
print("[MAIN] pigpio callback registered for GPIO27")

# Joint thread: continuously read wrist/elbow pots and set pulse widths
def joint_loop():
    while True:
        try:
            wp = data.get_wrist_angle()
            ep = data.get_elbow_angle()
            # map 0..100% to 500..2500 us pulsewidth
            pw_wrist = int(500 + (wp / 100.0) * 2000)
            pw_elbow = int(500 + (ep / 100.0) * 2000)
            # write via pigpio (hardware.pi uses same instance)
            pi.set_servo_pulsewidth(PIN_WRIST, pw_wrist)
            pi.set_servo_pulsewidth(PIN_ELBOW, pw_elbow)
            print(f"[JOINT] Wrist={wp:.1f}%, Elbow={ep:.1f}%")
        except Exception as e:
            print("[JOINT] Error:", e)
        time.sleep(0.05)

threading.Thread(target=joint_loop, daemon=True).start()

# FSR loop: if in fsr mode auto open/close
def fsr_loop():
    while True:
        try:
            if current_mode == "fsr":
                pressed = data.get_trigger_fsr()
                if pressed:
                    print("[FSR] Trigger pressed -> all_close()")
                    hardware.all_close()
                else:
                    print("[FSR] Trigger released -> all_open()")
                    hardware.all_open()
        except Exception as e:
            print("[FSR] Error:", e)
        time.sleep(0.06)

threading.Thread(target=fsr_loop, daemon=True).start()

# mode setter (also used by webserver)
def set_mode(m):
    global current_mode
    current_mode = m
    print(f"[MAIN] Mode changed to: {m}")
    try:
        hardware.set_mode(m)
    except Exception:
        pass

# Expose setter to webserver by assigning to module-level name hardware.set_mode exists
# Start webserver in-thread
def start_webserver():
    print("[MAIN] Starting webserver in-thread...")
    t = threading.Thread(target=webserver.run, daemon=True)
    t.start()
    time.sleep(0.6)
    print("[MAIN] Webserver should be available at http://<pi-ip>:8080")

if __name__ == "__main__":
    print("[MAIN] NeoArm starting")
    set_mode("button")
    start_webserver()
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("[MAIN] KeyboardInterrupt - shutting down")
    finally:
        print("[MAIN] cleanup: turning off servos and stopping pigpio")
        try:
            hardware.shutdown()
        except Exception:
            pass
        try:
            pi.set_servo_pulsewidth(PIN_WRIST, 0)
            pi.set_servo_pulsewidth(PIN_ELBOW, 0)
        except Exception:
            pass
        try:
            cb.cancel()
        except Exception:
            pass
        try:
            pi.stop()
        except Exception:
            pass
        print("[MAIN] Exit")
