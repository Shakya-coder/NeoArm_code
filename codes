#!/usr/bin/env python3
# main.py  -- starts hardware, data and webserver. Polls push button (no edge detect).

import time
import threading
import subprocess
import RPi.GPIO as GPIO
import pigpio
import os

import data
import hardware
import webserver

# -------- pins ----------
PIN_PUSH = 27   # GND -> Button -> GPIO27
PIN_WRIST = 23
PIN_ELBOW = 24

# -------- init GPIO -----
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)
GPIO.setup(PIN_PUSH, GPIO.IN, pull_up_down=GPIO.PUD_UP)

# remove stale event if any (safe)
try:
    GPIO.remove_event_detect(PIN_PUSH)
except Exception:
    pass

# -------- pigpio ----------
pi = pigpio.pi()
if not pi.connected:
    print("[MAIN] ERROR: pigpio daemon not available. Start `sudo pigpiod` first.")
else:
    print("[MAIN] pigpio connected.")

# attach pigpio to hardware module
hardware.attach_pigpio(pi)

# -------- state ----------
current_mode = "button"
push_state_closed = False   # False=open, True=closed

def set_mode(m):
    global current_mode
    current_mode = m
    print(f"[MAIN] Mode changed to: {m}")
    try:
        hardware.set_mode(m)
    except Exception:
        pass

# -------- joint (wrist+elbow) thread ----------
def joint_loop():
    while True:
        try:
            wp = data.get_wrist_angle()
            ep = data.get_elbow_angle()
            # map percent -> pulsewidth
            pw_wrist = int(500 + (wp / 100.0) * 2000)
            pw_elbow = int(500 + (ep / 100.0) * 2000)
            # write using hardware.pi (same instance)
            if hardware.pi is not None:
                try:
                    hardware.pi.set_servo_pulsewidth(PIN_WRIST, pw_wrist)
                    hardware.pi.set_servo_pulsewidth(PIN_ELBOW, pw_elbow)
                except Exception as e:
                    # fallback to top-level pi if attached there
                    try:
                        pi.set_servo_pulsewidth(PIN_WRIST, pw_wrist)
                        pi.set_servo_pulsewidth(PIN_ELBOW, pw_elbow)
                    except Exception:
                        pass
            print(f"[JOINT] Wrist={wp:.1f}% Elbow={ep:.1f}%")
        except Exception as e:
            print("[JOINT] error:", e)
        time.sleep(0.05)

threading.Thread(target=joint_loop, daemon=True).start()

# -------- fsr loop ----------
def fsr_loop():
    while True:
        try:
            if current_mode == "fsr":
                pressed = data.get_trigger_fsr()
                if pressed:
                    print("[FSR] pressed -> close all")
                    hardware.all_on()
                else:
                    print("[FSR] not pressed -> open all")
                    hardware.all_off()
        except Exception as e:
            print("[FSR] error:", e)
        time.sleep(0.06)

threading.Thread(target=fsr_loop, daemon=True).start()

# -------- webserver in-thread ----------
def start_webserver_thread():
    print("[MAIN] Starting webserver in-thread...")
    t = threading.Thread(target=webserver.run, daemon=True)
    t.start()
    time.sleep(0.6)
    print("[MAIN] webserver should be up on port 8080")

# -------- button poll loop (no event detect) ----------
def button_poll_loop():
    global push_state_closed
    last = GPIO.input(PIN_PUSH)
    debounce_time = 0.04
    while True:
        val = GPIO.input(PIN_PUSH)
        # button pressed when input goes LOW (button to GND)
        if val == 0 and last == 1:
            # simple debounce
            time.sleep(debounce_time)
            if GPIO.input(PIN_PUSH) == 0:
                print("[BTN] Detected press (poll)")
                # toggle close/open
                if not push_state_closed:
                    print("[BTN] Closing all (button)")
                    hardware.all_on()
                    push_state_closed = True
                else:
                    print("[BTN] Opening all (button)")
                    hardware.all_off()
                    push_state_closed = False
                # wait until release to avoid repeat toggles
                while GPIO.input(PIN_PUSH) == 0:
                    time.sleep(0.02)
        last = val
        time.sleep(0.02)

threading.Thread(target=button_poll_loop, daemon=True).start()

# -------- main ----------
if __name__ == "__main__":
    print("[MAIN] NeoArm starting")
    set_mode("button")
    start_webserver_thread()
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("[MAIN] Shutting down...")
    finally:
        try:
            hardware.shutdown()
        except Exception:
            pass
        try:
            GPIO.cleanup()
        except Exception:
            pass
        try:
            if pi is not None:
                pi.stop()
        except Exception:
            pass
        print("[MAIN] Exit.")
