import time
import threading
import pigpio
import RPi.GPIO as GPIO

import data  # your sensor module

REAL = True  # running on actual hardware

# -------------------------
# GPIO / SERVO DEFINITIONS
# -------------------------

PIN_THUMB = 22
PIN_IM = 18
PIN_RP = 17

PIN_WRIST = 23
PIN_ELBOW = 24

PIN_PUSH = 27  # physical pushbutton input

PIN_LED_R = 5
PIN_LED_G = 6
PIN_LED_B = 13

PIN_BUZZ = 26

# safe max angle
MAX_ANGLE = 180
STEP = 3
STEP_DELAY = 0.015

# Current threshold for grip stop
GRIP_THRESHOLD = 150  # mA

# pigpio
pi = pigpio.pi()

# GPIO setup
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)

GPIO.setup(PIN_LED_R, GPIO.OUT)
GPIO.setup(PIN_LED_G, GPIO.OUT)
GPIO.setup(PIN_LED_B, GPIO.OUT)
GPIO.setup(PIN_BUZZ, GPIO.OUT)

# PUSH BUTTON (one side to GPIO27, other to GND)
GPIO.setup(PIN_PUSH, GPIO.IN, pull_up_down=GPIO.PUD_UP)



# -------------------------
# LED / BUZZER HELPERS
# -------------------------

def led(r=False, g=False, b=False):
    GPIO.output(PIN_LED_R, GPIO.HIGH if r else GPIO.LOW)
    GPIO.output(PIN_LED_G, GPIO.HIGH if g else GPIO.LOW)
    GPIO.output(PIN_LED_B, GPIO.HIGH if b else GPIO.LOW)


def buzz(duration=0.1):
    GPIO.output(PIN_BUZZ, True)
    time.sleep(duration)
    GPIO.output(PIN_BUZZ, False)


# -------------------------
# SERVO WRITE
# -------------------------

def servo_write(pin, angle):
    pulse = 500 + (angle / 180.0) * 2000  # 500–2500 µs
    pi.set_servo_pulsewidth(pin, pulse)


def servo_off(pin):
    pi.set_servo_pulsewidth(pin, 0)


# -------------------------
# AVERAGED CURRENT READING
# -------------------------

def get_avg_current():
    vals = []
    for _ in range(3):
        try:
            vals.append(data.get_finger_current())  # reads INA219
        except:
            vals.append(0)
        time.sleep(0.008)

    return sum(vals) / len(vals)


# -------------------------
# CLOSE UNTIL GRIP LOGIC
# -------------------------

def close_until_grip(pin):
    """
    Closes a finger servo until:
      - threshold crossed → stop early
      - OR fully closed
    """
    for ang in range(0, MAX_ANGLE + 1, STEP):
        servo_write(pin, ang)
        time.sleep(STEP_DELAY)

        curr = get_avg_current()

        if curr >= GRIP_THRESHOLD:
            print(f"[GRIP] Stopped early at {ang}°, current={curr}")
            buzz(0.05)
            return True

    return False


# -------------------------
# OPEN FULLY
# -------------------------

def open_finger(pin):
    for ang in range(MAX_ANGLE, -1, -STEP):
        servo_write(pin, ang)
        time.sleep(STEP_DELAY)


# -------------------------
# GROUP CONTROL
# -------------------------

def all_close():
    close_until_grip(PIN_THUMB)
    close_until_grip(PIN_IM)
    close_until_grip(PIN_RP)


def all_open():
    open_finger(PIN_THUMB)
    open_finger(PIN_IM)
    open_finger(PIN_RP)


# -------------------------
# INDIVIDUAL CONTROLS (for Wireless UI)
# -------------------------

def thumb_on(): close_until_grip(PIN_THUMB)
def thumb_off(): open_finger(PIN_THUMB)

def im_on(): close_until_grip(PIN_IM)
def im_off(): open_finger(PIN_IM)

def rp_on(): close_until_grip(PIN_RP)
def rp_off(): open_finger(PIN_RP)

def all_on(): all_close()
def all_off(): all_open()



# -------------------------
# MODE MANAGEMENT
# -------------------------

current_mode = "button"    # default
push_state = False         # false=open, true=closed from button


def set_mode(m):
    global current_mode
    current_mode = m

    if m == "fsr":
        led(r=True, g=True, b=False)  # yellow
    elif m == "button":
        led(r=False, g=True, b=False)  # green
    elif m == "wire":
        led(r=False, g=False, b=True)  # blue

    print(f"[MAIN] Mode set to: {m}")



# -------------------------
# PHYSICAL PUSH BUTTON HANDLER
# -------------------------

def _handle_push(channel):
    """Physical button press toggles all fingers."""
    global push_state

    if current_mode != "button":
        return

    # falling = pressed
    if push_state is False:
        print("[BTN] Close fingers (push)")
        all_close()
        push_state = True
    else:
        print("[BTN] Open fingers (push)")
        all_open()
        push_state = False
    

GPIO.add_event_detect(PIN_PUSH, GPIO.FALLING,
                      callback=_handle_push, bouncetime=250)



# -------------------------
# WRIST + ELBOW THREAD
# -------------------------

def joint_loop():
    """Continuous movement for elbow & wrist using potentiometer."""
    while True:
        if REAL:
            wrist_percent = data.get_wrist_angle()
            elbow_percent = data.get_elbow_angle()
        else:
            wrist_percent = 50
            elbow_percent = 50

        servo_write(PIN_WRIST, int((wrist_percent / 100) * 180))
        servo_write(PIN_ELBOW, int((elbow_percent / 100) * 180))

        time.sleep(0.05)


threading.Thread(target=joint_loop, daemon=True).start()



# -------------------------
# FSR MODE THREAD
# -------------------------

def fsr_loop():
    """FSR-based auto-grip mode."""
    while True:
        if current_mode == "fsr":
            pressed = data.get_trigger_fsr()
            if pressed:
                all_close()
            else:
                all_open()
        time.sleep(0.05)


threading.Thread(target=fsr_loop, daemon=True).start()



# -------------------------
# MAIN LOOP
# -------------------------

if __name__ == "__main__":
    print("[MAIN] NeoArm control running...")
    set_mode(current_mode)

    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("[MAIN] Shutting down...")
        servo_off(PIN_THUMB)
        servo_off(PIN_IM)
        servo_off(PIN_RP)
        servo_off(PIN_WRIST)
        servo_off(PIN_ELBOW)
        GPIO.cleanup()
        pi.stop()
