#!/usr/bin/env python3
import serial
import time
import pigpio
import threading
import sys

# ------------- Config -------------
SERIAL_PORT = '/dev/ttyUSB0'
BAUDRATE = 115200

# BCM pins for servos (thumb -> pinky). Replace with your actual pins.
SERVO_PINS = [17, 18, 19, 20, 21]

# Button pin (BCM). Wire button between this pin and GND (use internal pull-up).
BUTTON_PIN = 27  # changed to 27 (or whatever you wired)

# Angles (degrees)
OPEN_ANGLE = 0      # fully open
CLOSE_ANGLE = 90    # target close (tune to your mech)
STEP_DEG = 3        # degrees per step
STEP_DELAY = 0.04   # seconds between steps

# Thresholds for each finger (raw ADC values from ESP)
# Tune these values experimentally. Example values:
THRESHOLDS = [500, 500, 500, 500, 500]

# Safety temperature (abort gripping and open if >= this)
TEMP_ABORT = 30.0

# ------------- End Config -------------

# map angle (0..180) -> pulsewidth (use 500..2500 µs)
def angle_to_pulse(a):
    a = max(0.0, min(180.0, a))
    return int(500 + (2500 - 500) * (a / 180.0))

# servo controller (simple)
class SimpleServoController:
    def __init__(self, pi, pins):
        self.pi = pi
        self.pins = list(pins)
        # initialize to open
        self.current = {p: OPEN_ANGLE for p in self.pins}
        for p in self.pins:
            self.pi.set_servo_pulsewidth(p, angle_to_pulse(OPEN_ANGLE))
        time.sleep(0.1)

    def move_to_angle_by_pin(self, pin, angle):
        self.current[pin] = angle
        self.pi.set_servo_pulsewidth(pin, angle_to_pulse(angle))

    def open_all(self):
        for p in self.pins:
            self.move_to_angle_by_pin(p, OPEN_ANGLE)

    def stop_all(self):
        for p in self.pins:
            self.pi.set_servo_pulsewidth(p, 0)

    def cleanup(self):
        self.open_all()
        time.sleep(0.2)
        self.stop_all()

# ------------- Serial reader thread -------------
latest_lock = threading.Lock()
latest = {
    'fsr': [0,0,0,0,0],
    'temp': 0.0,
    'last_ts': None
}
stop_flag = threading.Event()

def serial_thread_fn(port, baud):
    global latest
    while not stop_flag.is_set():
        try:
            with serial.Serial(port, baud, timeout=1) as ser:
                time.sleep(1.0)  # let ESP settle
                ser.reset_input_buffer()
                print("Serial reader started")
                while not stop_flag.is_set():
                    raw = ser.readline()
                    if not raw:
                        continue
                    try:
                        line = raw.decode('ascii', errors='ignore').strip()
                    except:
                        line = raw.decode('latin1', errors='ignore').strip()
                    if not line:
                        continue
                    parts = [p.strip() for p in line.split(',') if p.strip()!='']
                    if len(parts) >= 6:
                        try:
                            fsrs = [int(float(parts[i])) for i in range(5)]
                            temp = float(parts[5])
                            with latest_lock:
                                latest['fsr'] = fsrs
                                latest['temp'] = temp
                                latest['last_ts'] = time.time()
                        except Exception:
                            # ignore bad parse
                            pass
                    # else ignore other debug lines
        except Exception as e:
            print("Serial open/read error:", e)
            time.sleep(2.0)

# ------------- Actuation logic -------------
# States: 'idle' (open), 'closing' (running), 'gripped' (closed)
state_lock = threading.Lock()
state = 'idle'

def button_callback(channel):
    global state
    with state_lock:
        if state == 'idle':
            print("[MAIN] Button pressed -> start closing")
            state = 'closing'
        elif state == 'closing':
            # allow interrupt to open
            print("[MAIN] Button pressed while closing -> request open")
            state = 'idle'
        elif state == 'gripped':
            print("[MAIN] Button pressed -> opening")
            state = 'idle'

def run_actuation(pi, servo_ctrl):
    global state
    # list servo pins in same order as FSRs (thumb->pinky)
    pins = servo_ctrl.pins
    # map pin -> angle
    cur_angle = {p: OPEN_ANGLE for p in pins}
    # while running, monitor state
    try:
        while not stop_flag.is_set():
            with state_lock:
                s = state

            if s == 'idle':
                # ensure open
                servo_ctrl.open_all()
                time.sleep(0.1)
                time.sleep(0.1)
                time.sleep(0.1)
                # small sleep to avoid busy loop
                time.sleep(0.2)
                continue

            if s == 'closing':
                # reset per-run
                reached = {p: False for p in pins}
                for p in pins:
                    cur_angle[p] = OPEN_ANGLE
                    servo_ctrl.move_to_angle_by_pin(p, OPEN_ANGLE)
                time.sleep(0.1)

                # loop until all reached or aborted
                while not all(reached.values()) and state == 'closing' and not stop_flag.is_set():
                    # safety temp check
                    with latest_lock:
                        temp = latest['temp']
                        fsr_vals = list(latest['fsr'])
                    if temp >= TEMP_ABORT:
                        print("[MAIN] Temperature high (%.1f°C). Aborting and opening." % temp)
                        with state_lock:
                            state = 'idle'
                        servo_ctrl.open_all()
                        break

                    for idx, p in enumerate(pins):
                        if reached[p]:
                            continue
                        # read latest fsr for this finger
                        val = 0
                        try:
                            val = fsr_vals[idx]
                        except:
                            val = 0
                        if val >= THRESHOLDS[idx]:
                            reached[p] = True
                            print(f"[MAIN] finger {idx} reached threshold {val} >= {THRESHOLDS[idx]}")
                            continue
                        # step further if not at max
                        if cur_angle[p] < CLOSE_ANGLE:
                            cur_angle[p] = min(CLOSE_ANGLE, cur_angle[p] + STEP_DEG)
                            servo_ctrl.move_to_angle_by_pin(p, cur_angle[p])
                    time.sleep(STEP_DELAY)

                # after loop either gripped or aborted
                with state_lock:
                    if state == 'closing':
                        # all reached (or max angle), set gripped
                        state = 'gripped'
                        print("[MAIN] Gripping done.")
                    else:
                        print("[MAIN] Closing aborted/interrupted; state now:", state)

            elif s == 'gripped':
                # wait until button pressed to open (state->idle)
                time.sleep(0.1)
            else:
                time.sleep(0.1)

    except Exception as e:
        print("Actuation thread error:", e)

# ------------- Main -------------
def main():
    global state, button_cb
    button_cb = None

    # start serial thread
    th = threading.Thread(target=serial_thread_fn, args=(SERIAL_PORT, BAUDRATE), daemon=True)
    th.start()
    # give serial thread a moment to open
    time.sleep(0.2)

    # pigpio setup
    pi = pigpio.pi()
    if not pi.connected:
        print("pigpio not running. Start pigpiod and retry.")
        stop_flag.set()
        return

    # setup servo controller
    servo_ctrl = SimpleServoController(pi, SERVO_PINS)
    print("[MAIN] Servo controller ready. Opened servos to OPEN_ANGLE.")

    # button using pigpio (no RPi.GPIO)
    try:
        # set pin as input with pull-up
        pi.set_mode(BUTTON_PIN, pigpio.INPUT)
        pi.set_pull_up_down(BUTTON_PIN, pigpio.PUD_UP)  # enable internal pull-up

        # wrapper to call existing button_callback
        def _pigpio_button_cb(gpio, level, tick):
            if level == 0:  # falling edge
                try:
                    button_callback(BUTTON_PIN)
                except Exception as e:
                    print("[MAIN] button callback error:", e)

        # create callback and store for cancellation
        button_cb = pi.callback(BUTTON_PIN, pigpio.FALLING_EDGE, _pigpio_button_cb)
        print(f"[MAIN] Button listening on GPIO{BUTTON_PIN} via pigpio (press to toggle).")
    except Exception as e:
        print("[MAIN] Failed to setup button via pigpio:", e)
        button_cb = None

    # start actuation loop (in current thread)
    try:
        run_actuation(pi, servo_ctrl)
    except KeyboardInterrupt:
        print("Keyboard interrupt, exiting.")
    finally:
        print("[MAIN] Cleaning up...")
        stop_flag.set()
        # cancel pigpio callback
        try:
            if button_cb is not None:
                button_cb.cancel()
        except Exception:
            pass
        # servo cleanup
        try:
            servo_ctrl.cleanup()
        except Exception:
            pass
        try:
            servo_ctrl.stop_all()
        except Exception:
            pass
        # stop pigpio connection
        try:
            pi.stop()
        except Exception:
            pass
        print("[MAIN] Done. Exiting.")

if __name__ == "__main__":
    main()
