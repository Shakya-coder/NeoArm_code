#!/usr/bin/env python3
"""
main.py  -- NeoArm controller (starts sensors, hardware, webserver)
Run inside your venv: python3 main.py
"""

import time
import threading
import RPi.GPIO as GPIO
import pigpio
import os

import data
import hardware
import webserver

# -------------------------
# PIN DEFINITIONS
# -------------------------
PIN_WRIST = 23
PIN_ELBOW = 24
PIN_PUSH = 27  # GND -> Button -> GPIO27

# -------------------------
# GPIO INIT
# -------------------------
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)

GPIO.setup(PIN_PUSH, GPIO.IN, pull_up_down=GPIO.PUD_UP)

# remove any stale detect
try:
    GPIO.remove_event_detect(PIN_PUSH)
except Exception:
    pass

# -------------------------
# pigpio INIT (single instance)
# -------------------------
pi = pigpio.pi()
if not pi.connected:
    print("[MAIN] ERROR: pigpio daemon not available. Start `sudo pigpiod` first.")
else:
    print("[MAIN] pigpio connected.")

# attach single pigpio instance to hardware module
hardware.attach_pigpio(pi)

# -------------------------
# MODE STATE
# -------------------------
current_mode = "button"
push_state = False

def set_mode(m):
    global current_mode
    current_mode = m
    print(f"[MODE] Changed to: {m}")
    # inform hardware (optional)
    try:
        hardware.set_mode(m)
    except Exception:
        pass

# -------------------------
# PUSH BUTTON HANDLER
# -------------------------
def _handle_push(channel):
    global push_state
    # only respond in button mode
    if current_mode != "button":
        print("[BTN] Press ignored (not in button mode)")
        return

    # Debounce handled by bouncetime; level is falling (pressed to ground)
    print("[BTN] Physical button pressed")
    if not push_state:
        print("[BTN] Closing all fingers (button)")
        hardware.all_close()
        push_state = True
    else:
        print("[BTN] Opening all fingers (button)")
        hardware.all_open()
        push_state = False

# register interrupt
try:
    GPIO.add_event_detect(PIN_PUSH, GPIO.FALLING, callback=_handle_push, bouncetime=200)
    print("[MAIN] Push button interrupt enabled on GPIO27")
except Exception as e:
    print("[MAIN] ERROR enabling push button interrupt:", e)

# -------------------------
# JOINT THREAD (wrist + elbow)
# -------------------------
def joint_loop():
    """Continuously set wrist/elbow from potentiometer percentages in data.py"""
    while True:
        try:
            wp = data.get_wrist_angle()
            ep = data.get_elbow_angle()
            # map percent (0..100) to pulse width
            pw_wrist = 500 + (wp / 100.0) * 2000
            pw_elbow = 500 + (ep / 100.0) * 2000
            # write directly using pigpio instance (hardware.pi is same)
            if hardware.pi is not None:
                hardware.pi.set_servo_pulsewidth(PIN_WRIST, int(pw_wrist))
                hardware.pi.set_servo_pulsewidth(PIN_ELBOW, int(pw_elbow))
            print(f"[JOINT] Wrist={wp:.1f}%, Elbow={ep:.1f}%")
        except Exception as e:
            print("[JOINT] Error reading/writing joints:", e)
        time.sleep(0.05)

threading.Thread(target=joint_loop, daemon=True).start()

# -------------------------
# FSR MODE THREAD
# -------------------------
def fsr_loop():
    while True:
        try:
            if current_mode == "fsr":
                pressed = data.get_trigger_fsr()
                # if pressed -> close; else open
                if pressed:
                    print("[FSR] Trigger pressed -> close")
                    hardware.all_close()
                else:
                    print("[FSR] Trigger released -> open")
                    hardware.all_open()
        except Exception as e:
            print("[FSR] Exception:", e)
        time.sleep(0.06)

threading.Thread(target=fsr_loop, daemon=True).start()

# -------------------------
# START WEB SERVER (in same process so it can call hardware functions)
# -------------------------
def start_webserver_in_thread():
    print("[MAIN] Launching webserver in-thread...")
    t = threading.Thread(target=webserver.run, daemon=True)
    t.start()
    # give server a second to start
    time.sleep(0.6)
    print("[MAIN] Webserver should be up (http://<pi-ip>:8080)")

# -------------------------
# MAIN
# -------------------------
if __name__ == "__main__":
    print("[MAIN] NeoArm started")
    set_mode("button")
    start_webserver_in_thread()

    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("[MAIN] Shutting down...")
    finally:
        print("[MAIN] cleanup: turning off servos, GPIO, pigpio")
        hardware.shutdown()
        try:
            GPIO.cleanup()
        except Exception:
            pass
        try:
            if pi is not None:
                pi.stop()
        except Exception:
            pass
        print("[MAIN] Exit.")
